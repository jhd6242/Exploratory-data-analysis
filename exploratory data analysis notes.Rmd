---
title: "Exploratory Data Analysis"
author: "Justin DeCross"
date: "September 24, 2018"
output: html_document
---
# Getting and Cleaning Data Notes
## Week 1
###Principles of Analytic Graphics
#### Principles of Analytic Graphic
 * Principal 1: Show Comparisons
      + Evidence for a Hypothesis is always relative to another competing hypothesis.
      + Always ask "Compared to What?"
 * Principal 2: Show causality,  mechanism,  explanation, systematic structure
      + What is your casual framework for thinking about a question?
 * Principal 3: Show multivariate data
      + Multivariate=more than 2 variables
      + The real world is multivariate
      + Need to "escape flatland"
 * Principal 4: Integration of evidence
      + Completely integrate word, numbers, images, diagrams
      + Data graphics should make use of many mode of data presentation
      + Don't let the tool drive the analysis
 * Principal 5: Describe and document the evidence with appropriate labels, scales, sources, etc.
      + A data graphic should tell a complete story that is credible
 * Principal 6: Content is king
      + Analytical presentations ultimately stand or fall depending on the quality, relevance, and integrity of their content

#### Show Comparisons
 * box graph
 * show causality, mechanism
 
#### Show multivariate data
 * Daily mortality rate Verse particulate matter
 * 4 different graphs comparing the different seasons  when it comes to particulate matter versus mortality rate
 
#### Integrate different modes of evidence
 * example of clean plots
 
#### Summary
 * Principal 1: Show comparisons
 * Principal 2: Show causality, mechanism, explanation
 * Principal 3: Show multivariate data
 * Principal 4: Integrate multiple modes of evidence
 * Principal 5: Describe and document the evidence
 * Principal 6: Content
 
### Exploratory Graphs (part 1)
#### Exploratory graphs
#### Why do we use graphs in data analysis?
 * To understand data properties
 * To find patterns in data
 * To suggest modeling strategies
 * To"debug" analyses
 * To communicate results
 
#### Characteristics of exploratory graphs
 * They are made quickly
 * A large number are made
 * The goal is for personal understanding
 * Axes/legends are generally cleaned up(later)
 * Color/size are primarily used for information

#### Air Pollution in the United States
 * The US Environmental Protection Agency(EPA) Sets national ambient air quality standards for outdoor air pollution.
 * Question: Are there any counties in the US that exceed the national standard for fine particle pollution?
 
#### Data
 * Can't find data set for example
 
#### Simple Summaries of Data
 * One dimension
    + 5-number summary
    + Boxplots
    + Histograms
    + Density plot
    + Barplot
    
#### 5-number Summary
#### Boxplot
#### Histogram
 * rug function
 
#### Overlaying Features
 * overlaying a horizontal line over the box plot
 * overlaying a vertical line over the histogram
 
#### Barplot
 * Summarizes a categorical variable

### Exploratory Graphs(part 2)

#### Simple Summaries of Data

 * 2 dimensions
    + Multiple/overlaid 1D plots(Lattice/ggplot2)
    + Scatterplots
    + Smooth scatterplots
 * 2 dimensions
    + overlaid/multiple 2D Plots; co-plots
    + Use color, size, shape to add dimensions
    + Spinning plots
    + Actual 3D plot(not that useful)
    
#### Multiple Boxplots  

#### Multiple Histograms

#### Scatterplot
 * abline() does a overlay
 * use color
 * Use multiple scatterplot to display  East and West variables
 
#### Summary
 * Exploratory plots are "quick and dirty"
 * Let you summarize the data(usually graphically) and highlight any broad features
 * Explore basic questions and hypotheses(and perhaps rule them out)
 * Suggest modeling strategies for the"next step"
 
### Plotting Systems in R

#### The Base Plotting System
 * "Artist's palette" model
 * Start with blank canvas and build up from there
 * Start with plot function(or similar)
 * Use annotation functions to add/modify( text, lines, points, axis)
 * Convenient, mirrors how we think of building plots and analyzing data
 * Can't go back once plot has started(i.e. to adjust margins); need to plan in advance
 * Difficult to"translate" to others once a new plot has been created(no graphical "language")
 * Plot is this a series of R commands
 
#### Base Plot

```{r}
library(datasets)
data(cars)
with(cars, plot(speed, dist))
```
 

#### The Lattice System
 * Plots are created with a single function call(xyplot, bwplot, etc.)
 * Most useful for conditioning types of plots: Looking at how y changes with x across levels of z
 * Things like margins/spacing set automatically because entire plot is specified at once
 * Good for putting many many plots on a screen
 * Sometimes awkward to specify and the entire plot in a single function call
 * Annotation in plot is not especially intuitive
 * Use of panel functions and subscripts difficult to wield and requires intense preparation
 * Cannot "add" to the plot once it is created
 
#### Lattice Plot

```{r}
library(lattice)
state <- data.frame(state.x77, region = state.region)
xyplot(Life.Exp~Income |  region, data = state, layout = c(4, 1))

```
 
#### The ggplot2 System
 * Splits the difference between base and lattice in a number of ways
 * Automatically deals with spacings, text, titles but also allows you to annotate by"adding to a plot"
 * Superficial similarity to lattice but generally easier/more intuitive to use
 * Default  mode makes many choices for you (but you can still customize to your hearts desire)
 
#### ggplot2 Plot

```{r}
library(ggplot2)
data(mpg)
qplot(displ, hwy, data = mpg)
```

#### Summary
 * Base:"artist's palette" model
 * Lattice: Entire plot specified by one function; conditioning
 * ggplot2: Mixes elements of Base and Lattice
 
### Base Plotting System(part 1)
#### Plotting System
 * The core plotting and graphics engine in R is encapsulated in the following packages:
    + graphics: contains plotting functions for the"base" graphing systems, including plot, hist, box  plot and many others.
    + grDevices: Contains all the code implementing the various graphics devices, including X11, PDF,  PostScript, PNG, etc.
 * The lattice plotting system is implemented using the following  packages:
    + lattice: contains code for producing Trellis graphics, which are independent of the"base" graphics system; includes functions like xyplot, bwplot, levelplot
    + grid: implements a different graphing system independent of the"base" system;; the lattice package builds on top of the grid; we seldom call functions from the grid package directly
    
#### The Process of Making a Plot
When making a plot one must 1st make a few considerations(not necessarily in this order):

 * Where will the plot be made? On the screen? Can a file?
 * How will the plot be used?
    + Is the plot for viewing temporarily on the screen?
    + Will it be presented in a web browser?
    + Will it eventually end up in a paper that might be printed?
    + Are you using it in a presentation?
 * Is there a large amount of data going into the plot? Or is it just a few points?
 * Do you need to be able to dynamically resize a graphic?
 
#### The Process of Making a Plot
 * What graphics system will you use: base, lattice, or ggplot2? These generally cannot be mixed.
 * Base graphics are usually constructed piece mail, with each aspect of the plot handled separately through a series of function calls; this is often conceptually simpler and allows plotting to mirror  the thought process
 * Lattice graphics are usually created in a single function call, so all the graphics parameters have to be specified at once; specifying everything out once allows R to automatically calculate the necessary spacings and font sizes.
 * ggplot2 combines concepts from both base and lattice graphics but uses it independent implementation
 
We focus on using the base plotting system to create graphics on the screen device.

#### Base Graphics
Base graphics are used most commonly and are very powerful system for creating 2D graphics.

 * There are 2 phases to creating a base plot
    + Initializing a new plot
    + Annotating(adding to) an existing plot
 * Calling plot(x, y) or hist(x) will launch a graphics device(if one is not already open) and draw a new plot On the device
 * If the arguments to plot are not the same special class, then the default method for plot is called; this function has many arguments, letting you set the title, X Axis label, Y Axis label, etc.
 * The base graphics system has many parameters that can be set and tweaked; these parameters are documented in ?par; it wouldn't hurt to try to memorize this help page!
 
#### Simple Base Graphics: Histogram

```{r}
library(datasets)
hist(airquality$Ozone)
```
 


#### Simple Base Graphics: Scatterplot

```{r}
library(datasets)
with(airquality, plot(Wind, Ozone))
```
    
#### Simple Base Graphics: Boxplot

```{r}
library(datasets)
airquality <- transform(airquality, Month  = factor(Month))
boxplot(Ozone~Month, airquality, xlab = "Month", ylab = "Ozone (ppb)")


```


#### Important Base Graphics Parameters

Many days plotting function share a set of parameters. Here are a few key ones:

 * pch: the plotting symbol(default is  open circle)
 * lty: the line type(default is solid line),can be dashed, dotted, etc.
 * lwd: the line width, specified as integer multiple
 * col: the plotting color, specified as a number, string, or hex code; the colors() function gives you a vector of  colors by name
 * xlab: character string for the X axis label
 * ylab: character string for the y axis label
 
#### Some Important Base Graphics Parameters

The par() function is used to specify global  graphics parameters that affect all plots in an R session. These parameters can be overridden when specified as arguments  to specific plotting functions.
 * las: the orientation of the axis labels on the plot
 * bg: the background color
 * mar: the margin size
 * oma: the outer margin size( default is 0 for all sides)
 * mfrow: number of plots per row, column(plots are filled row--wise)
 * mfcol; number of plots per row, column( plots are filled column-wise)
 
#### Some Important  Base Graphics Parameters

Default values for global graphics parameters

```{r}
par("lty")

par("col")

par("pch")

par("bg")

par("mar")

par("mfrow")
```


### Base Plotting System(part 2)

#### Base Plotting Functions

 * plot: make a scatterplot, or other type of plot depending on the class  of the object being plotted
 * lines: add lines to their plot, given a vector x values and a corresponding vector of y values (or a 2-column matrix); this function just connects the dots
 * points: add points to a plot
 * text: add text labels to a plot using specified x, y coordinates
 * title: Add annotations to x,y axis labels, title, subtitle, outer margin
 * mtext: add arbitrary tax to the margins (inner or outer) of the plot
 * axis: adding axis ticks/labels

#### Base Plot with Annotation

```{r}
library(datasets)
with(airquality, plot(Wind, Ozone))
title(main = "Ozone and Wind in New York City") # Add a title
```


```{r}
with(airquality, plot(Wind, Ozone, main = "Ozone and Wind in New York City"))
with(subset(airquality, Month == 5), points(Wind, Ozone, col = "blue"))

```


```{r}
with(airquality, plot(Wind, Ozone, main = "Ozone and Wind in New York City", type = "n"))
with(subset(airquality, Month == 5), points(Wind, Ozone, col = "blue"))
with(subset(airquality, Month!= 5), points(Wind, Ozone, col = "red"))
legend("topright", pch = 1, col = c("blue","red"), legend = c("May","Other Months"))
```


#### Base Plot with Regression Line

```{r}
with(airquality, plot(Wind, Ozone, main = "Ozone and Wind in New York City", pch = 20))
model <- lm(Ozone ~ Wind, airquality)
abline(model, lwd = 2)
```


#### Multiple Base Plots

```{r}
par(mfrow = c(1, 2))
with(airquality, {
	plot(Wind, Ozone, main = "Ozone and Wind")
	plot(Solar.R, Ozone, main = "Ozone and Solar Radiation")
})
```

```{r}
par(mfrow = c(1, 3), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0))
with(airquality, {
	plot(Wind, Ozone, main = "Ozone and Wind")
	plot(Solar.R, Ozone, main = "Ozone and Solar Radiation")
	plot(Temp, Ozone, main = "Ozone and Temperature")
	mtext("Ozone and Weather in New York City", outer = TRUE)
})
```

#### Summary

 * Plots in the base plotting system are created by calling successive R functions to"build up" a plot
 * Plotting occurs in 2 stages:
      + Creation of a plot
      + Annotation of a plot (adding lines, points, text, legend)
 * The base plotting system is very flexible and offers a high degree of control over plotting
 
### Base Plotting Demonstration

### Graphics Devices in R

#### What is a Graphics Device?

 * A graphics device is something where you can make a plot appear
      + A window on your computer(screen device)
      + A PDF file(file device)
      + A PNG or JPEG file(file device)
      + A scalable Vector graphics(SVG) file(file device)
 * When you make a plot in R it has to be "sent" to a specific graphics device
 * The most common place for a pot to be "sent" is the screen device
      + On a Mac the screen device is launched with the quartz()
      + On Windows the screen device is launched with windows()
      + On UNIX/Linux screen device is launched with x11()
      
#### What is a Graphic Device?

 * When making a plot, you need to consider how the plot will be used to determine what device the plot should be sent to.
      + The list of devices is found in ?Devices; there are also devices created by users on CRAN
 * For quick visualization and exploratory analysis, usually you want to see the screen device
      + Functions like plot in base, xyplot in lattice, or qplot in ggplot2 will default to sending a plot to the screen
      + For a given platform(Mac, Windows, UNIX/Linux) there is only one screen device
 * For plots that may be printed out to be incorporated into a document(e.g. papers/reports, slide presentations), usually a file device is more appropriate
      + There are many different file devices to choose from
 * NOTE: not all graphics devices are available on all platforms(i.e. you cannot launch the windows() on a Mac)

#### How Does a Plot Get Created?

There are two basic approaches to plotting. The 1st is most common:

 * Call a plotting function like plot, xyplot, or qplot
 * The plot appears on the screen device
 * Annotate plot if necessary
 * Enjoy

```{r}
library(datasets)
with(faithful, plot(eruptions, waiting))	# Make plot appear on screen device
title(main = "Old Faithful Geyser data")	# Annotate with a title

```

#### How Does a Plot Get Created?

The 2nd approach to plotting and most commonly used for file devices:

 * Explicitly launch a graphic device
 * Call a plotting function to make a plot(Note: if you are using a file device, no plot will appear on the screen)
 * Annotate plot if necessary
 * explicitly close graphics device with dev.off()(this is very important!)

```{r}
library(datasets)
pdf(file = "myplot.pdf")	# Open PDF device; create 'myplot.pdf' in my working directory
# Create plot and then to a file(no plot appears on screen)
with(faithful, plot(eruptions, waiting))
title(main = "Old Faithful Geyser data")	# Annotate plot; still nothing on screen
dev.off()	# Close the PDF file device
# Now you can view the file 'myplot.pdf' on your computer
```


### Graphics Devices in R(part 2)

#### Graphics File Devices

There are 2 basic types of file devices: vector and bitmap devices

Vector formats:

 * pdf: useful for line-type graphics, resizes well, usually portable, not efficient if a plot has many objects/points
 * svg: XML-based scalable Vector graphics: supports animation and interactivity, potentially useful for web-based plot
 * win.metafile: Windows metafile format(only on Windows)
 * postscript: older format, also resizes well, usually portable, can be used to create encapsulated postscript files; Windows systems often don't have a postscript viewer
 
 
#### Graphics File Devices

Bitmap formats

 * png: bitmapped format, good for line drawings or images with solid colors, uses lossless compression(like the old GIF format), most web browsers can read this format natively, good for plotting many many many points, does not resize well
 * jpeg: good for photographs or natural scenes, uses lossy compression, good for plotting many many many points, does not resize well, can be read by almost any computer and any web browser, not great for line drawings
 * tiff: Creates bitmap files in the TIFF format; supports lossless compression
 * bmp: a native Windows bitmapped format


#### Multiple Open Graphics Devices

 * It is possible to open multiple graphics devices(screen, file, or both), for example when viewing multiple plots at once
 * Plotting can only occur on one graphics device at a time
 * The currently active graphics device can be found by calling dev.cur()
 * Every open graphics device designed an integer greater than or equal to 2
 * You can change the active graphics device with dev.set(<integer>) where <integer> is the number associated with the graphics device you want to switch to

#### Copying Plots

Copying a plot to another device can be useful because some plots require a lot of code and they can be a pain to type all that in again for a different device.

 * dev.copy: copy a plot from one device to another
 * dev.copy2pdf: specifically copy a plot to a PDF file
NOTE: Copying a plot is not an exact operation, so the results may not be identical to the original.

```{r}
library(datasets)
with(faithful, plot(eruptions, waiting))	# Create plot on a screen device
title(main = "Old Faithful Geyser data")	# Add a main title
dev.copy(png, file = "geyserplot.png")	# Copy my plot to a PNG file
dev.off()	# Don't forget to close the PNG device!
```

#### Summary

 * Plots must be created on a graphics device
 * The default graphics device is almost always the screen device, which is most useful for exploratory analysis
 * File devices are useful for creating plots that can be included in other documents or sent to other people
 * For file devices, there are vector and bitmap formats
      + Vector formats are good for line drawings and plots with solid colors using a modest number of points
      + Bitmap formats are good for plot with a large number of points, natural scenes or web-based plot

## Week 2

### Lattice Plotting System(part 1)

#### The Lattice Plotting System

The lattice plotting system is implemented using the following packages:

 * lattice: contains code for producing Trellis graphics, which are independent of the "base" graphics system; includes functions like xyplot, bwplot, levelplot
 * grid: implement a different graphing system independent of the "base" system; the lattice package builds on top of grid
      + We seldom call functions from the grid package directly
 * The lattice plotting system does not have a "two-phase" aspect with separate plotting and annotation like in base plotting
 * All plotting/annotation is done at once with a single function call

#### Lattice Functions

 * xyplot: this is the main function for creating scatterplots
 * bwplot: box-and-whiskers plots ("boxplots")
 * histogram: histograms
 * stripplot: like a boxplot with actual points
 * splom: scatterplot matrix; like pairs in base plotting system
 * levelplot, contourplot: for plotting "image" plot

#### Lattice Functions

Lattice function generally take a formula for their 1st argument, usually of the form


xyplot(y ~ x  | f * g, data)


 * We use the formula notations here, hence the ~.
 * On the left side of the ~ is the y-axis variable, on the right is the x-axis variable
 * f and g are conditioning variables – they are optional
      + the * indicates an interaction between 2 variables
 * the 2nd argument is the data frame or list for which the variable in the formula should be looked up
      + If no data frame or list is passed, then the parent frame is used.
 * If no other arguments are passed, there are defaults that can be used.

#### Simple Lattice Plot

```{r}
library(lattice)
library(datasets)
# simple scatterplot
xyplot(Ozone ~ Wind, data = airquality)
```

#### Simple Lattice Plot

```{r}
library(datasets)
library(lattice)
# convert 'Month' to a factor variable
airquality <- transform(airquality, Month = factor(Month))
xyplot(Ozone ~ Wind | Month, data = airquality, layout = c(5, 1))
```

#### Lattice Behavior

Lattice functions behave differently from base graphics function in 1 Critical Way.

 * Base graphics function plot data directly to the graphics device(screen, PDF file, etc.)
 * Lattice graphics functions return an object of class trellis
 * The print methods for lattice functions actually do the work of plotting the data on the graphics device.
 * Lattice functions return "plot objects" that can, in principle, be stored (but it's actually better to just save the code + data)
 * On the command line, trellis objects are auto-printed so that it appears the function is plotting the data

#### Lattice Behavior

```{r}
p <- xyplot(Ozone ~ Wind, data = airquality)# Nothing Happens!
print(p) # Plot Appears

xyplot(Ozone ~ Wind, data = airquality)# Auto-Printing

```

### Lattice Plotting System(part 2)

#### Lattice Panel Functions

 * Lattice functions have a panel function which controls what happens inside each panel of the plot.
 * The lattice package comes with default panel functions, but you can supply your own if you want to customize what happens in each panel
 * Panel functions received the x/y coordinates of the data points in their panel(along with any optional arguments)

#### Lattice Panel Functions

```{r}
set.seed(10)
x <- rnorm(100)
f <- rep(0:1, each = 50)
y <- x + f - f * x + rnorm(100, sd = 0.5)
f <- factor(f, labels  = c("Group 1","Group 2"))
xyplot(y ~ x | f, layout = c(2, 1)) # Plot with 2 panels
```

#### Lattice Panel Functions

```{r}
# Custom Panel Function
xyplot(y ~ x | f, panel = function(x,y,...) {
	panel.xyplot(x,y,...)# 1st call the default panel function for 'xyplot'
	panel.abline(h = median(y), lty = 2)# Add a horizontal line to the median
})
```

#### Lattice Panel Functions: Regression Line

```{r}
# Custom panel function
xyplot(y ~ x | f, panel = function(x,y,...) {
	panel.xyplot(x,y,...)# 1st call default panel function
	panel.lmline(x,y, col = 2)# Overlay a simple linear regression line
})

```

#### Many Panel Lattice Plot: Example from MAACS

 * Study: Mouse Allergen and Asthma Cohort Study(MAACS)
 * Study subjects: Children with asthma living in Baltimore city, many allergic to mouse allergen
 * Design: Observational study, baseline home visit + every 3 months for a year.
 * Question: How does indoor airborne mouse allergen vary over time and across subjects?


#### Many Panel Lattice Plot
graph

#### Summary
 * Lattice plots are constructed with a single function call to a core lattice function(e.g. xyplot)
 * Aspects like margins and spacing are automatically handled and defaults are usually sufficient
 * The lattice system is ideal for creating conditioning plots where you examine the same kind of plot under many different conditions
 * Panel functions can be specified/customized to modify what is plotted in each of the plot panels
 
### ggplot2(part 1)

#### What is ggplot2?

 * An implementation of the Grammar of Graphics by Leland Wilkinson
 * Written by Haley Wickham(while he was a graduate student at Iowa State)
 * A "third" graphics system for R(along with base and lattice)
 * Available from CRAN via install.packages()

#### what is ggplot2?

 * Grammar of graphics represents an abstraction of graphics ideas/objects
 * Think "verb", "noun", "adjective" for graphics
 * Allows for a "theory" of graphics on which to build new graphics and graphics objects
 * "Shorten the distance from mind to page"

#### Grammar of Graphics
"In brief, the grammar tells us that a statistical graphic is a mapping from data to as static attributes(color, shape, size) of geometric objects(points, lines, bars). The plot may also contain statistical transformations of the data and is drawn on a specific coordinate system"

#### The Basics: qplot()

 * Works much like the plot function in base graphics system
 * Looks for the data in a data frame, similar to lattice, or in the parent environment
 * Plots are made up of aesthetics(sides, shape, color) and geoms(points, lines)

#### The Basics: qplot()

 * Factors are important for indicating subsets of data (if they are to have different properties); they should be labeled
 * The qplot() hides what goes on underneath, which is okay for most operations
 * ggplot() is the core function and very flexible for doing things qplot() cannot do

### ggplot2(part 2)
 
#### Example DataSet

```{r}
library(ggplot2)
str(mpg)
```


#### ggplot2 "Hello, world!"

```{r}
library(ggplot2)
qplot(displ, hwy, data = mpg)
```


#### Modifying aesthetics

```{r}
library(ggplot2)

qplot(displ, hwy, data = mpg, color = drv)

```

#### Adding a geom

```{r}
library(ggplot2)

qplot(displ, hwy, data = mpg,geom = c("point","smooth"))

```
#### Histograms

```{r}
library(ggplot2)

qplot(hwy, data = mpg,fill = drv)
```
#### Facets

```{r}
library(ggplot2)

qplot(displ,hwy, data = mpg, facets = .~drv)

qplot(hwy, data = mpg, facets = drv ~., binwidth = 2)
```
#### MAACS Cohort

 * Mouse Allergen and Asthma Cohort Study
 * Baltimore children(age 5-17)
 * Persistent asthma, exacerbation in past year
 * Study indoor environment and its relationship with asthma mobility


#### Example: MAACS



#### The next couple of slides do not contain publicly available data

#### Summary of qplot()

 * The qplot() function is the analog to plot() but with many built in features
 * Syntax somewhere in between base/lattice
 * Produces very nice graphics, essentially publication ready(if you like the design)
 * Difficult to go against the grain/customize(don't bother; use full ggplot2 power in that case)

### ggplot2(part 3)

#### Basic Components of a ggplot2 Plot

 * A data frame
 * aesthetic mappings: how data are mapped to color, size
 * geoms: geometric objects like points, lines, shapes.
 * facets: for conditional plots.
 * stats: statistical transformations like binning, quantiles, smoothing.
 * scales: what scale and aesthetic map uses(example: male = red, female = blue).
 * coordinate systems
 
#### Building Plots with ggplot2

 * When building plot in ggplot2(rather than using qplot) the "artist's palette" model may be the closest analogy
 * Plots are built up in layers
      + Plot the data
      + Overlay a summary
      + Metadata and annotation

#### The example is not publicly available

### ggplot2 (part 4)

#### The example is not publicly available

#### Annotation

 * Labels: xlab(), ylab(), labs(), ggtitle()
 * Each of the "geom" functions has options to modify
 * For things that only make sense globally, use theme()
      + Example: theme(legend.position = "none")
 * Two standard appearance themes are included
      + theme_gray(): The default theme(gray background)
      + theme_bw(): More stark/plain

#### Modify Aesthetics
example is not publicly available

#### Modify Labels
example is not publicly available

#### Customizing the Smooth
example is not publicly available

#### Changing the Theme
example is not publicly available

### ggplot2(part 5)

#### A Notes about Axis Limits

```{r}
library(ggplot2)
testdata <- data.frame(x = 1:100, y = rnorm(100))
testdata[50, 2] <- 100 # Outlier!
plot(testdata$x, testdata$y, type = "l", ylim = c(-3, 3))

g <- ggplot(testdata, aes(x = x, y = y))
g + geom_line()

g + geom_line() + ylim(-3, 3)
g + geom_line() + coord_cartesian(ylim = c( -3, 3 ))
```


#### More Complex Example
Example is not publicly available

#### Making NO2 Tertiles
Example is not publicly available

#### Final Plot
Example is not publicly available

#### Code for Final Plot
Example is not publicly available

#### Summary

 * ggplot2 is very powerful and flexible if you learn the "grammar" and the various elements that can be tuned/modified
 * Many more types of plots can be made; explore and mess around with the package(references mentioned in Part 1 are useful)
 
## Week 3
### Hierarchical Clustering(part 1)
#### Hierarchical Clustering
#### Can we find things that are close together?

Clustering organizes that are close into groups

 * How do we define close?
 * How do we group things?
 * How do we visualize the grouping?
 * How do we interpret the grouping?

#### Hugely important/impactful
cluster analysis

#### Hierarchical clustering

 * An agglomerative approach
      + Find closest 2 things
      + Put them together
      + Find next closest
 * Requires
      + A defined distance
      + A merging approach
 * Produces
      + A tree showing how close things are to each other
#### How do we define close?

 * Most important step
		+ Garbage in <- garbage out
 * Distance or similarity
		+ Continuous - Euclidean distance
		+ Continuous - correlation similarity
		+ Binary - manhattan distance
 * Pick a distance/similarity that makes sense to your problem

#### Example distances - Euclidean

#### Example distances - Manhattan

### Hierarchical clustering(part 2)

#### Hierarchical clustering - example

```{r}
set.seed(1234)
par(mar = c(0, 0, 0, 0))
x <- rnorm(12, mean = rep(1:3, each = 4), sd = 0.2)
y <- rnorm(12, mean = rep(c(1, 2, 1), each = 4),sd = 0.2)
plot(x,y,col = "blue", pch = 19, cex = 2)
text(x +0.05, y + 0.05, labels  = as.character(1:12))
```

#### Hierarchical clustering - dist
 * Important parameters: x, method

```{r}
dataFrame <- data.frame(x = x, y = y)
dist(dataFrame)
```

#### Hierarchical clustering - #1

#### Hierarchical clustering - #2

#### Hierarchical clustering - #3

#### Hierarchical clustering - hclust

```{r}
dataFrame <- data.frame(x = x, y = y)
distxy <- dist(dataFrame) 
hClustering <- hclust(distxy)
plot(hClustering)
```

### Hierarchical Clustering(part 3)
#### Prettier  dendrograms

```{r}
myplclust <- function( hclust, lab=hclust$labels, lab.col=rep(1,length(hclust$labels)), hang=0.1,...){
 ## modifiction of plclust for plotting hclust objects *in colour*!
 ## Copyright Eva KF Chan 2009
 ## Arguments:
 ##    hclust:    hclust object
 ##    lab:        a character vector of labels of the leaves of the tree
 ##    lab.col:    colour for the labels; NA=default device foreground colour
 ##    hang:     as in hclust & plclust
 ## Side effect:
 ##    A display of hierarchical cluster with coloured leaf labels.
 y <- rep(hclust$height,2)
 x <- as.numeric(hclust$merge)
 y <- y[which(x<0)]
 x <- x[which(x<0)]
 x <- abs(x)
 y <- y[order(x)]
 x <- x[order(x)]
 plot(hclust, labels=FALSE, hang=hang, ...)
 text(x=x, y=y[hclust$order]-(max(hclust$height)*hang), labels=lab[hclust$order], col=lab.col[hclust$order], srt=90, adj=c(1,0.5), xpd=NA, ... )}

```

#### Prettier dendrograms(part 2)

```{r}
 dataFrame <- data.frame(x=x,y=y)
 distxy <- dist(dataFrame)
 hClustering <- hclust(distxy)
 myplclust(hClustering , lab = rep(1:3, each = 4), lab.col = rep(1:3, each = 4))
```

#### heatmap()

```{r}
dataFrame <- data.frame(x = x, y = y)
set.seed(143)
dataMatrix <- as.matrix(dataFrame)[sample(1:12), ]
heatmap(dataMatrix)
```


#### Notes and further resources

 * Gives an idea of the relationship between variables/observations
 * The picture may be unstable
      + Change a few points
      + Have different missing values
      + Pick a different distance
      + Change the merging strategy
      + Change the scale of points for one variable
 * But it is deterministic
 * Choosing where to cut isn't always obvious
 * Should be primary use for exploration
 
### K-Means Clustering(part 1)
#### Can we find things that are close together?

 * How do we define close?
 * How do we group things?
 * How do we visualize the grouping?
 * How do we interpret the grouping?

#### How do we define close?
 * Most important step
		+ Garbage in  = garbage out
 * Distance or similarity
		+ Continuous - euclidean distance
		+ Continuous - correlation similarity
		+ Binary - manhattan distance
 * Pick a distance/similarity that makes sense for your problem

#### K-means clustering

 * A partitioning approach
		+ Fix a number of clusters
		+ Get "centroids" of each cluster
		+ Assign things to closest centroid
		+ Recalculate centroids
 * Requires
		+ A defined distance metric
		+ A number of clusters
		+ An initial guess as to cluster centroids
 * Produces
		+ Final estimate of cluster centroids
		+ An assignment of each point to clusters
		
#### K-means clustering - example

```{r}
set.seed(1234)
par(mar = c(0, 0, 0, 0))
x <- rnorm(12, mean = rep(1:3, each = 4), sd = 0.2)
y <- rnorm(12, mean = rep(c(1, 2, 1), each = 4), sd = 0.2)
plot(x, y, col = "blue", pch = 19, cex = 2)
text(x + 0.05, y +0.05, labels = as.character(1:12))
```

#### K-means – starting centroids

#### K-means clustering – assign to closest centroid

#### K-means clustering – recalculate centroids

#### K-means clustering – reassign values

#### K-means clustering – update centroids

#### kmeans()

 * Important parameters: x, centers, iter.max, nstart

```{r}
dataFrame <- data.frame(x, y)
kmeansObj <- kmeans(dataFrame, centers = 3)
names(kmeansObj)

kmeansObj$cluster
```


#### kmeans()

```{r}
par(mar = rep(0.2, 4))
plot(x,y, col = kmeansObj$cluster, pch = 19, cex = 2)
points(kmeansObj$cluster, col = 1:3, pch = 3, cex = 3, lwd = 3)
```

#### Heatmaps

```{r}
set.seed(1234)
dataMatrix <- as.matrix(dataFrame)[sample(1:12), ]
kmeansObj2 <- kmeans(dataMatrix, centers = 3)
par(mfrow = c(1,2), mar = c(2, 4, 0.1, 0.1))
image(t(dataMatrix)[,nrow(dataMatrix):1], yaxt = "n")
image(t(dataMatrix)[,order(kmeansObj$cluster)], yaxt = "n")
```


#### Notes and further resources

 * K-means requires a number of clusters
      + Pick by eye/intuition
      + Pick by cross validation/information theory, etc.
      + Determining the number of clusters
 * K-means is not deterministic
      + Different # of clusters
      + Different number of iterations
      
### Dimension Reduction (part 1)

#### Matrix data

```{r}
set.seed(12345)
par(mar = rep(0.2, 4))
dataMatrix <- matrix(rnorm(400),nrow = 40)
image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])
```

#### Cluster the data
```{r}
par(mar = rep(0.2, 4))
heatmap(dataMatrix)
```
#### What if we add a pattern?

```{r}
set.seed(678910)
for (i in 1:40){

	coin_Flip <- rbinom(1, size = 1, prob = 0.5)
	if (coin_Flip) {
		dataMatrix[i, ] <- dataMatrix[i, ] + rep(c(0, 3), each = 5)
	}
}
```

#### What if we add a pattern? – the data

```{r}
par(mar = rep(0.2, 4))
image(1: 10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])
```
#### What if we add a pattern? – the clustered data

```{r}
par(mar = rep(0.2, 4))
heatmap(dataMatrix)
```
#### Patterns in rows and columns

```{r}
hh <- hclust(dist(dataMatrix))
data_Matrix_Ordered <- dataMatrix[hh$order, ]
par(mfrow = c(1, 3))
image(t(data_Matrix_Ordered)[, nrow(data_Matrix_Ordered):1])
plot(rowMeans(data_Matrix_Ordered), 40:1, , xlab = "Row Mean", ylab = "Row", pch = 19)
plot(colMeans(data_Matrix_Ordered), xlab = "Column",ylab = "Column Mean", pch = 19)
```
#### Related problems

You have multivariate variables X1,..., Xn so X1 = (X11,...,Xlm)
 * Find a new set of multivariate variables that are uncorrelated explain as much variance as possible.
 * If you put all the variables together in one matrix, find the best matrix created with fewer variable (lower rank) that explains the original data.
The 1st goal is statistical in the 2nd goal is data compression.

#### Related solutions – PCA/SVD

SVD
 * If X is a matrix with each variable in a column in each observation in a row then the SVD is a "matrix decomposition"
 * X = UDV^T
 * where the columns of U are orthogonal (left singular vectors), the columns of V are orthogonal(right single vectors) and D is a diagonal matrix(singular values).
PCA
 * the principal components are equal to the right singular value if you 1st scale(subtract the mean, divide by the standard deviation) the variables.
